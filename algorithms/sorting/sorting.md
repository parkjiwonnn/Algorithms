# 정렬(Sorting)

정렬을 사용하여 오름차순 및 내림차순으로 정렬되어 있다면 특정 원소를 좀 더 효율적으로 찾을 수 있음

| 이름                       | 최선     | 평균     | 최악     | 평균 공간 복잡도 |
| -------------------------- | -------- | -------- | -------- | ---------------- |
| 삽입 정렬 (Insertion Sort) | O(n)     | O(n^2)   | O(n^2)   | O(1)             |
| 버블 정렬 (Bubble Sort)    | O(n)     | O(n^2)   | O(n^2)   | O(1)             |
| 합병 정렬 (Merge Sort)     | O(nlogn) | O(nlogn) | O(nlogn) | O(n)             |
| 퀵 정렬 (Quick Sort)       | O(nlogn) | O(nlogn) | O(n^2)   | O(logn)          |
| 힙 정렬 (Heap Sort)        | O(nlogn) | O(nlogn) | O(nlogn) | O(1)             |

데이터의 특성, 크기에 따라 적절한 정렬 방법을 사용해야 함

## 삽입 정렬(Insertion Sort)

배열의 모든 원소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성  
배열이 길어질수록 효율이 떨어지지만, 구현이 간단하다는 장점 존재

## 버블 정렬(Bubble Sort)

배열의 인접한 두 수를 선택하여, 정렬되지 않았다면 두 수를 바꿈(swap)  
이를 배열의 처음부터 끝까지 반복하고, 배열에 아무 변화가 없을 때까지 함  
구현이 간단하지만, 느림

## 합병 정렬(Merge Sort)

정렬되지 않은 리스트를 각각 하나의 원소만 포함하는 n개의 부분 리스트로 분할(원소의 개수가 하나인 리스트는 이미 정렬된 것으로 봄)  
부분 리스트가 하나만 남을 때까지 반복해서 병합하며 정렬된 부분 리스트를 생성  
마지막 남은 부분 리스트가 정렬된 리스트

## 퀵 정렬(Quick Sort)

배열의 요소들 중에서 피벗(Pivot)을 정하여, 피벗의 앞에는 피벗보다 작은 원소들이 오고, 피벗 뒤에는 피벗보다 큰 값이 오도록 배열을 둘로 나눔

분할된 두 개의 배열의 크기가 0이나 1이 될 때까지, 분할된 두 배열에 대해 재귀적으로 이 과정을 반복

재귀 호출이 한 번 진행될 때마다 최소한 하나의 원소가 최종적인 위치에 있게 되므로, 종료됨이 보장

### 힙 정렬(Heap Sort)

최대 힙 구성(최대 힙이란 부모 노드가 자식 노드보다 큰 트리를 의미)  
현재 힙에서 가장 큰 값(루트의 값)을 마지막 요소와 바꾼 후, 힙의 사이즈를 하나 줄이고 최대 힙 구성  
힙의 사이즈가 1이 될 때까지 위 과정을 반복

### Python의 라이브러리 내장 sort 함수 구현

Python은 팀 정렬(Tim Sort)  
팀 정렬 : 합병 정렬 + 삽입 정렬
